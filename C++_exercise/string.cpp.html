<p>/<strong><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em></strong></p>

<blockquote>
  <p>File Name: my_String.cpp
Author: 刘怪怪
Mail: 
Created Time: 2017年12月18日 星期一 09时51分40秒
 <strong><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em>**</strong>/</p>
</blockquote>

<h1>include<iostream></h1>

<h1>include<netinet/in.h></h1>

<h1>include<netinet/in.h></h1>

<h1>include<sys/socket.h></h1>

<h1>include<arpa/inet.h></h1>

<h1>include<assert.h></h1>

<h1>include<signal.h></h1>

<h1>include<unistd.h></h1>

<h1>include<stdlib.h></h1>

<h1>include<stdio.h></h1>

<h1>include<string.h></h1>

<p>using namespace std;</p>

<p>class my<em>String
{
    int size1;   //字符个数
    char *ptr;  //指向这个字符串
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,my</em>String&amp; str);
    friend istream&amp; operator>>(istream&amp; os,my<em>String&amp; str);
    public:
       // explicit my</em>String(const char  *otr);   //显式构造
        my<em>String(const char *otr) ;   //隐式构造
        my</em>String(const my<em>String &amp; str);
        my</em>String(int h ,char a);
        ~my<em>String() {if(ptr) delete []ptr;  }
        int size() const {return  size1;}
        char &amp; operator [] (int i )  //重载[]
        {
            return ptr[i];
        }
        my</em>String &amp; operator = (  my<em>String &amp;str); // 重载 = 
       // my</em>String &amp; operator = ( char *str);</p>

<p>};</p>

<p>my<em>String::my</em>String(const  char  *otr):size1(strlen(otr))  //可做默认构造函数　　或　my_string(“hhhh”);
{
    if(!otr) {
        ptr = NULL;
    }else{
        ptr =  new char[size1 + 1];
        memcpy( ptr ,otr,size1 + 1);
       // ptr[size1] = '\0';
    }
}</p>

<p>my<em>String::my</em>String(const my_String &amp;str):size1(str.size())
{
    if(!str.ptr) 
        ptr = NULL;
    else{
        ptr =  new char [size1 + 1];
        memcpy(ptr, str.ptr, size1+1);
       // ptr[size1] = '\0';
    }
}</p>

<p>my<em>String::my</em>String(int h, char a):size1(h)
{
    if(h > 0 ){
        ptr = new  char[h+1];
        for(int  i =0;i<h;i++)
            ptr[i] = a;
        ptr[h] = '\0';
    }else{
        ptr = NULL;
    }
}</p>

<p>//重载= my<em>String a = b;
my</em>String&amp; my<em>String::operator = ( my</em>String &amp;str)
{
    size1 = strlen(str.ptr);
    ptr  = new char[size1 + 1]; 
    memcpy(ptr,str.ptr,size1+1); </p>

<pre><code>return *this;
</code></pre>

<p>}
//重载＝ my<em>String a = "1234";
/*
my</em>String&amp; my_String::operator = ( char * str)
{
    size1 = strlen(str);
    ptr  = new char[size1 + 1]; 
    memcpy(ptr,str,size1+1); </p>

<pre><code>return *this;
</code></pre>

<p>}<em>/
ostream&amp; operator &lt;&lt; (ostream&amp; os,my_String&amp; mtr)  //重载运算符&lt;&lt; <br />
{ <br />
    os &lt;&lt; mtr.ptr; <br />
    return os; <br />
} 
istream&amp; operator >> (istream&amp; os,my_String&amp; str)
{
    char temp[255];
    os >> setw(255) >> temp;
    str =  temp;
    return os;
}
int main ()
{
    char  *a = (char</em>)"helloworld";
   // my<em>String s  ("hello world");
    my</em>String s(a);
    // my<em>String b = my</em>String("12345");   //重载 =  //显式构造　　
    my<em>String b = "12345";// 隐式构造
    cout &lt;&lt; b.size() &lt;&lt;  b &lt;&lt; endl;
    my</em>String h;
    cin >> h;
    cout&lt;<h&lt;<endl;</p>

<p>}</p>
